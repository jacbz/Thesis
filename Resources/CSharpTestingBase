public static bool CIEquals(this String a, String b) {
    return a.Equals(b, StringComparison.CurrentCultureIgnoreCase);
}

public static bool IsNumeric(this object o) => o is double || o is int || o is ushort || o is uint || o is ulong ||
												  o is short || o is sbyte || o is long || o is float || o is byte ||
												  o is decimal;

// same as Object.Equals, but returns true for numbers of different types
public static bool Equals(object a, object b)
{
	if (IsNumeric(a) && IsNumeric(b))
	{
		return double.Equals(Convert.ToDouble(a), Convert.ToDouble(b));
	}
	return Object.Equals(a, b);
}

// Implementation of Excel's round function that supports negative digits
public static double Round(double value, double digits)
{
    if (digits >= 0)
    {
        return Math.Round(value, (int)digits, MidpointRounding.AwayFromZero);
    }
    else
    {
        digits = Math.Abs(digits);
        double temp = value / Math.Pow(10, digits);
        temp = Math.Round(temp, 0, MidpointRounding.AwayFromZero);
        return temp * Math.Pow(10, digits);
    }
}

public static double RoundUp(double value, double digits)
{
    var power = Math.Pow(10, digits);
    return Math.Ceiling(value * power) / power;
}

public static double RoundDown(double value, double digits)
{
   var power = Math.Pow(10, digits);
   return Math.Floor(value * power) / power;
}

public class Matrix
{
	public dynamic[,] Items { get; set; }
	
	public static Matrix Of(params Row[] rows)
	{
		Matrix matrix = new Matrix();
		int rowCount = rows.Length;
		int columnCount = rows.Max(c => c.Items.Length);
		dynamic[,] items = new dynamic[rowCount, columnCount];

		for(int j = 0; j < rowCount; j++)
		{
			for(int k = 0; k < columnCount; k++)
			{
				items[j, k] = rows[j].Items.Length > k ? rows[j].Items[k] : new EmptyCell();
			}
		}
		matrix.Items = items;
		return matrix;
	}

	public static Matrix Of(params Column[] columns)
	{
		Matrix matrix = new Matrix();
		int rowCount = columns.Max(c => c.Items.Length);
		int columnCount = columns.Length;
		dynamic[,] items = new dynamic[rowCount, columnCount];

		for(int j = 0; j < rowCount; j++)
		{
			for(int k = 0; k < columnCount; k++)
			{
				items[j, k] = columns[k].Items.Length > j ? columns[k].Items[j] : new EmptyCell();
			}
		}
		matrix.Items = items;
		return matrix;
	}	

	public dynamic[] Flatten()
	{
		return Items.Cast<dynamic>().ToArray();
	}

	public double Sum()
	{
		return Flatten().Sum();
	}

	public double Min()
	{
		return Flatten().Min();
	}

	public double Max()
	{
		return Flatten().Max();
	}
	
	public dynamic VLookUp(dynamic lookupValue, int column, dynamic matchMode = null)
	{
		if(matchMode == null || Object.Equals(matchMode, true) || Object.Equals(matchMode, 1))
		{
			// approximate match
			return Items[ApproximateMatchRowIndex(lookupValue, 0), column - 1];
		}
		else if(Object.Equals(matchMode, false) || Object.Equals(matchMode, 0))
		{
			// exact match
			return Items[ExactMatchRowIndex(lookupValue, 0), column - 1];
		}
		throw new ArgumentException("Match mode has invalid value");
	}
	
	public dynamic HLookUp(dynamic lookupValue, int row, dynamic matchMode = null)
	{
		if(matchMode == null || Object.Equals(matchMode, true) || Object.Equals(matchMode, 1))
		{
			// approximate match
			return Items[row - 1, ApproximateMatchColumnIndex(lookupValue, 0)];
		}
		else if(Object.Equals(matchMode, false) || Object.Equals(matchMode, 0))
		{
			// exact match
			return Items[row - 1, ExactMatchColumnIndex(lookupValue, 0)];
		}
		throw new ArgumentException("Match mode has invalid value");
	}

	public int ExactMatchRowIndex(dynamic value, int column)
	{
		if(IsNumeric(value))
		{
			decimal valueNum = Convert.ToDecimal(value);
			for(int i = 0; i < Items.GetLength(0); i++)
			{
				dynamic curr = Items[i, column];
				if (IsNumeric(curr) && Convert.ToDecimal(curr) == valueNum)
					return i;
			}
		}
		else if (value is string valueString)
		{
			for(int i = 0; i < Items.GetLength(0); i++)
			{
				dynamic curr = Items[i, column];
				if (curr is string currString && currString == valueString)
					return i;
			}
		}
		return -1;
	}

	public int ExactMatchColumnIndex(dynamic value, int row)
	{
		if(IsNumeric(value))
		{
			decimal valueNum = Convert.ToDecimal(value);
			for(int i = 0; i < Items.GetLength(1); i++)
			{
				dynamic curr = Items[row, i];
				if (IsNumeric(curr) && Convert.ToDecimal(curr) == valueNum)
					return i;
			}
		}
		else if (value is string valueString)
		{
			for(int i = 0; i < Items.GetLength(1); i++)
			{
				dynamic curr = Items[row, i];
				if (curr is string currString && currString == valueString)
					return i;
			}
		}
		return -1;
	}

	public int ApproximateMatchRowIndex(dynamic value, int column)
	{
		if(IsNumeric(value))
		{
			decimal valueNum = Convert.ToDecimal(value);
			for(int i = 0; i < Items.GetLength(0); i++)
			{
				dynamic curr = Items[i, column];
				if (!IsNumeric(Items[i,column]) && !(curr is EmptyCell))
					return -1;
				decimal currNum = Convert.ToDecimal(curr);
				if (currNum == valueNum)
					return i;
				if (currNum > valueNum)
					return i - 1;
			}
		}
		else if (value is string valueString)
		{
			for(int i = 0; i < Items.GetLength(0); i++)
			{
				dynamic curr = Items[i, column];
				if (curr is string currString)
				{
					int compare = valueString.CompareTo(currString);
					if (compare == 0)
						return i;
					if (compare == -1)
						return i - 1;
				}
			}
		}
		return -1;
	}

	public int ApproximateMatchColumnIndex(dynamic value, int row)
	{
		if(IsNumeric(value))
		{
			decimal valueNum = Convert.ToDecimal(value);
			for(int i = 0; i < Items.GetLength(1); i++)
			{
				dynamic curr = Items[row, i];
				if (!IsNumeric(curr) && !(curr is EmptyCell))
					return -1;
				decimal currNum = Convert.ToDecimal(curr);
				if (currNum == valueNum)
					return i;
				if (currNum > valueNum)
					return i - 1;
			}
		}
		else if (value is string valueString)
		{
			for(int i = 0; i < Items.GetLength(1); i++)
			{
				dynamic curr = Items[row, i];
				if (curr is string currString)
				{
					int compare = valueString.CompareTo(currString);
					if (compare == 0)
						return i;
					if (compare == -1)
						return i - 1;
				}
			}
		}
		return -1;
	}
}

public class Row : Collection
{
	public static Row Of(params object[] items)
	{
		Row row = new Row();
		row.Items = items;
		return row;
	}
}

public class Column : Collection
{	
	public static Column Of(params object[] items)
	{
		Column column = new Column();
		column.Items = items;
		return column;
	}	
}

public class Collection
{
	public object[] Items { get; set; }

	protected Collection()
	{
		Items = new object[0];
	}

	// flatten on arrival
	public static Collection Of(params object[] items)
	{
		Collection collection = new Collection();
		if (items == null) return collection;

		var flattenedItems = new List<object>();
		foreach(object obj in items)
		{
			if (obj == null) continue;
			if (obj is Collection ic)
				flattenedItems.AddRange(ic.Items);
			else
				flattenedItems.Add(obj);
		}
		collection.Items = flattenedItems.ToArray();
		return collection;
	}

	public double Sum()
	{
		return Items.Sum();
	}

	public double Min()
	{
		return Items.Min();
	}

	public double Max()
	{
		return Items.Max();
	}
}

public static double Sum(this dynamic[] items)
{
	double result = 0;
	foreach(dynamic obj in items)
	{
		if(obj is Matrix m)
			result += m.Sum();
		else if(IsNumeric(obj))
			result += Convert.ToDouble(obj);
		else if (obj is string s && double.TryParse(s, out double d))
			result += d;
	}
	return result;
}

// Calculates the minimum. Ignores everything except numbers and strings
public static double Min(this dynamic[] items)
{
	var min = Double.MaxValue;
	foreach(dynamic obj in items)
	{
		if(obj is Matrix m)
			min = Math.Min(min, m.Min());
		else if(IsNumeric(obj))
			min = Math.Min(min, Convert.ToDouble(obj));
		else if (obj is string s && double.TryParse(s, out double d))
			min = Math.Min(min, d);
	}
	// if no valid arguments were provided, return 0
	return min == Double.MaxValue ? 0 : min;
}

// Calculates the minimum. Ignores everything except numbers and strings
public static double Max(this dynamic[] items)
{
	var max = Double.MinValue;
	foreach(dynamic obj in items)
	{
		if(obj is Matrix m)
			max = Math.Max(max, m.Max());
		else if(IsNumeric(obj))
			max = Math.Max(max, Convert.ToDouble(obj));
		else if (obj is string s && double.TryParse(s, out double d))
			max = Math.Max(max, d);
	}
	// if no valid arguments were provided, return 0
	return max == Double.MinValue ? 0 : max;
}

public struct EmptyCell
{
    public static dynamic operator +(dynamic a, EmptyCell b)
    {
        return a;
    }

    public static dynamic operator +(EmptyCell a, dynamic b)
    {
        return b;
    }

    public static EmptyCell operator +(EmptyCell a, EmptyCell b)
    {
        return a;
    }

    public static dynamic operator -(dynamic a, EmptyCell b)
    {
        return a;
    }

    public static dynamic operator -(EmptyCell a, dynamic b)
    {
        return 0 - b;
    }

    public static dynamic operator -(EmptyCell a, EmptyCell b)
    {
        return 0;
    }

    public static dynamic operator *(dynamic a, EmptyCell b)
    {
        return 0;
    }

    public static dynamic operator *(EmptyCell a, dynamic b)
    {
        return 0;
    }

    public static dynamic operator *(EmptyCell a, EmptyCell b)
    {
        return 0;
    }

    public static dynamic operator /(dynamic a, EmptyCell b)
    {
        throw new System.DivideByZeroException();
    }

    public static dynamic operator /(EmptyCell a, dynamic b)
    {
        return 0;
    }

    public static dynamic operator /(EmptyCell a, EmptyCell b)
    {
        throw new System.DivideByZeroException();
    }

    public static dynamic operator %(dynamic a, EmptyCell b)
    {
        throw new System.DivideByZeroException();
    }

    public static dynamic operator %(EmptyCell a, dynamic b)
    {
        return 0;
    }

    public static dynamic operator %(EmptyCell a, EmptyCell b)
    {
        throw new System.DivideByZeroException();
    }

    public static bool operator ==(dynamic a, EmptyCell empty)
    {
        if (IsNumeric(a)) return a == 0;
        switch (a)
        {
            case string s:
                return s == "";
            case bool b:
                return b == false;
            default:
                return false;
        }
    }

    public static bool operator ==(EmptyCell a, dynamic b)
    {
        return b == a;
    }

    public static bool operator ==(EmptyCell a, EmptyCell b)
    {
        return true;
    }

    public static bool operator !=(dynamic a, EmptyCell b)
    {
        return !(a == b);
    }

    public static bool operator !=(EmptyCell a, dynamic b)
    {
        return !(b == a);
    }

    public static bool operator !=(EmptyCell a, EmptyCell b)
    {
        return false;
    }

    public static bool operator <(dynamic a, EmptyCell b)
    {
        return a < 0;
    }

    public static bool operator <(EmptyCell a, dynamic b)
    {
        return 0 < b;
    }

    public static bool operator <(EmptyCell a, EmptyCell b)
    {
        return false;
    }

    public static bool operator >(dynamic a, EmptyCell b)
    {
        return a > 0;
    }

    public static bool operator >(EmptyCell a, dynamic b)
    {
        return 0 > b;
    }

    public static bool operator >(EmptyCell a, EmptyCell b)
    {
        return false;
    }

    public static bool operator <=(dynamic a, EmptyCell b)
    {
        return a <= 0;
    }

    public static bool operator <=(EmptyCell a, dynamic b)
    {
        return 0 <= b;
    }

    public static bool operator <=(EmptyCell a, EmptyCell b)
    {
        return true;
    }

    public static bool operator >=(dynamic a, EmptyCell b)
    {
        return a >= 0;
    }

    public static bool operator >=(EmptyCell a, dynamic b)
    {
        return 0 >= b;
    }

    public static bool operator >=(EmptyCell a, EmptyCell b)
    {
        return true;
    }

    public static dynamic operator !(EmptyCell a)
    {
        return true;
    }

    public static implicit operator double(EmptyCell a) => 0;
    public static implicit operator string(EmptyCell a) => "";
    public static implicit operator bool(EmptyCell a) => false;

    public override bool Equals(object obj)
    {
        return obj == this;
    }

    public override int GetHashCode()
    {
        return 0;
    }
}