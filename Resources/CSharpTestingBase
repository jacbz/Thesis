public static bool CIEquals(this String a, String b) {
    return a.Equals(b, StringComparison.CurrentCultureIgnoreCase);
}

public static bool IsNumeric(this object o) => o is double || o is int || o is ushort || o is uint || o is ulong ||
												  o is short || o is sbyte || o is long || o is float || o is byte ||
												  o is decimal;

// same as Object.Equals, but returns true for numbers of different types
public static bool Equals(object a, object b)
{
	if (IsNumeric(a) && IsNumeric(b))
	{
		return double.Equals(Convert.ToDouble(a), Convert.ToDouble(b));
	}
	return Object.Equals(a, b);
}

// Implementation of Excel's round function that supports negative digits
public static double Round(double value, double digits)
{
    if (digits >= 0)
    {
        return Math.Round(value, (int)digits, MidpointRounding.AwayFromZero);
    }
    else
    {
        digits = Math.Abs(digits);
        double temp = value / Math.Pow(10, digits);
        temp = Math.Round(temp, 0, MidpointRounding.AwayFromZero);
        return temp * Math.Pow(10, digits);
    }
}

public static double RoundUp(double value, double digits)
{
    var power = Math.Pow(10, digits);
    return Math.Ceiling(value * power) / power;
}

public static double RoundDown(double value, double digits)
{
   var power = Math.Pow(10, digits);
   return Math.Floor(value * power) / power;
}

// so we don't have to write "new" for a new collection
public static InternalCollection Collection(params object[] items)
{
	return new InternalCollection(items);
}

public class InternalCollection
{
	public object[] Items { get; }

	// flatten on arrival
	public InternalCollection(params object[] items)
	{
		var flattenedItems = new List<object>();
		foreach(object obj in items)
		{
			if (obj is InternalCollection ic)
				flattenedItems.AddRange(ic.Items);
			else
				flattenedItems.Add(obj);
		}
		Items = flattenedItems.ToArray();
	}

	public double Sum()
	{
		double result = 0;
		foreach(object obj in Items)
		{
			if(obj.IsNumeric())
				result += Convert.ToDouble(obj);
			else if (obj is string s && double.TryParse(s, out double d))
				result += d;
		}
		return result;
	}

	// Calculates the minimum. Ignores everything except numbers and strings
	public double Min()
	{
		var min = Double.MaxValue;
		foreach(object obj in Items)
		{
			if(obj.IsNumeric())
				min = Math.Min(min, Convert.ToDouble(obj));
			else if (obj is string s && double.TryParse(s, out double d))
				min = Math.Min(min, d);
		}
		// if no valid arguments were provided, return 0
		return min == Double.MaxValue ? 0 : min;
	}

	// Calculates the minimum. Ignores everything except numbers and strings
	public double Max()
	{
		var max = Double.MinValue;
		foreach(object obj in Items)
		{
			if(obj.IsNumeric())
				max = Math.Max(max, Convert.ToDouble(obj));
			else if (obj is string s && double.TryParse(s, out double d))
				max = Math.Max(max, d);
		}
		// if no valid arguments were provided, return 0
		return max == Double.MinValue ? 0 : max;
	}
}

public struct EmptyCell
{
    public static dynamic operator +(dynamic a, EmptyCell b)
    {
        return a;
    }

    public static dynamic operator +(EmptyCell a, dynamic b)
    {
        return b;
    }

    public static EmptyCell operator +(EmptyCell a, EmptyCell b)
    {
        return a;
    }

    public static dynamic operator -(dynamic a, EmptyCell b)
    {
        return a;
    }

    public static dynamic operator -(EmptyCell a, dynamic b)
    {
        return 0 - b;
    }

    public static dynamic operator -(EmptyCell a, EmptyCell b)
    {
        return 0;
    }

    public static dynamic operator *(dynamic a, EmptyCell b)
    {
        return 0;
    }

    public static dynamic operator *(EmptyCell a, dynamic b)
    {
        return 0;
    }

    public static dynamic operator *(EmptyCell a, EmptyCell b)
    {
        return 0;
    }

    public static dynamic operator /(dynamic a, EmptyCell b)
    {
        throw new System.DivideByZeroException();
    }

    public static dynamic operator /(EmptyCell a, dynamic b)
    {
        return 0;
    }

    public static dynamic operator /(EmptyCell a, EmptyCell b)
    {
        throw new System.DivideByZeroException();
    }

    public static dynamic operator %(dynamic a, EmptyCell b)
    {
        throw new System.DivideByZeroException();
    }

    public static dynamic operator %(EmptyCell a, dynamic b)
    {
        return 0;
    }

    public static dynamic operator %(EmptyCell a, EmptyCell b)
    {
        throw new System.DivideByZeroException();
    }

    public static bool operator ==(dynamic a, EmptyCell empty)
    {
        if (IsNumeric(a)) return a == 0;
        switch (a)
        {
            case string s:
                return s == "";
            case bool b:
                return b == false;
            default:
                return false;
        }
    }

    public static bool operator ==(EmptyCell a, dynamic b)
    {
        return b == a;
    }

    public static bool operator ==(EmptyCell a, EmptyCell b)
    {
        return true;
    }

    public static bool operator !=(dynamic a, EmptyCell b)
    {
        return !(a == b);
    }

    public static bool operator !=(EmptyCell a, dynamic b)
    {
        return !(b == a);
    }

    public static bool operator !=(EmptyCell a, EmptyCell b)
    {
        return false;
    }

    public static bool operator <(dynamic a, EmptyCell b)
    {
        return a < 0;
    }

    public static bool operator <(EmptyCell a, dynamic b)
    {
        return 0 < b;
    }

    public static bool operator <(EmptyCell a, EmptyCell b)
    {
        return false;
    }

    public static bool operator >(dynamic a, EmptyCell b)
    {
        return a > 0;
    }

    public static bool operator >(EmptyCell a, dynamic b)
    {
        return 0 > b;
    }

    public static bool operator >(EmptyCell a, EmptyCell b)
    {
        return false;
    }

    public static bool operator <=(dynamic a, EmptyCell b)
    {
        return a <= 0;
    }

    public static bool operator <=(EmptyCell a, dynamic b)
    {
        return 0 <= b;
    }

    public static bool operator <=(EmptyCell a, EmptyCell b)
    {
        return true;
    }

    public static bool operator >=(dynamic a, EmptyCell b)
    {
        return a >= 0;
    }

    public static bool operator >=(EmptyCell a, dynamic b)
    {
        return 0 >= b;
    }

    public static bool operator >=(EmptyCell a, EmptyCell b)
    {
        return true;
    }

    public static dynamic operator !(EmptyCell a)
    {
        return true;
    }

    public static implicit operator double(EmptyCell a) => 0;
    public static implicit operator string(EmptyCell a) => "";
    public static implicit operator bool(EmptyCell a) => false;

    public override bool Equals(object obj)
    {
        return obj == this;
    }

    public override int GetHashCode()
    {
        return 0;
    }
}